/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-OCR.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : OCR
 #	author : miyako
 #	2021/01/03
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-OCR.h"

#if VERSIONWIN

using namespace winrt;

using namespace Windows::Foundation;
using namespace Windows::Storage;
using namespace Windows::Storage::Streams;
using namespace Windows::Graphics::Imaging;
//using namespace Windows::Media::FaceAnalysis;
using namespace Windows::Media::Ocr;

using namespace Windows::Devices::Enumeration;
using namespace Windows::Media::Devices;

using namespace Windows::Security::Cryptography;
using namespace Windows::Globalization;
using namespace Windows::Foundation::Collections;

using namespace concurrency;

typedef std::pair<hstring, Rect> ocr_word;
typedef std::vector<ocr_word> ocr_words;
typedef std::vector<ocr_words> ocr_lines;
typedef std::pair<hstring, ocr_lines> ocr_result;

#pragma mark -

static void getDllPath(std::wstring &dllPath)
{
	wchar_t fDrive[_MAX_DRIVE],
		fDir[_MAX_DIR],
		fName[_MAX_FNAME],
		fExt[_MAX_EXT];

	wchar_t thisPath[_MAX_PATH] = { 0 };

	HMODULE hplugin = GetModuleHandleW(L"OCR.4DX");
	GetModuleFileNameW(hplugin, thisPath, _MAX_PATH);
	_wsplitpath_s(thisPath, fDrive, fDir, fName, fExt);
	std::wstring windowsPath = fDrive;
	windowsPath += fDir;

	if (windowsPath.at(windowsPath.size() - 1) != L'\\')
		windowsPath += L"\\";

	dllPath = windowsPath;
}

static HMODULE loadDll(const wchar_t *dllName) {

	std::wstring dllPath;
	getDllPath(dllPath);
	dllPath += dllName;

	return ::LoadLibrary((const wchar_t *)dllPath.c_str());
}

static void OnStartup() {
	
}

static void OnExit() {

}

#endif

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
		case kInitPlugin:
		case kServerInitPlugin:
//			OnStartup();
			break;

		case kDeinitPlugin:
		case kServerDeinitPlugin:
//			OnExit();
			break;
				
			// --- OCR
            
			case 1 :
				ocr_picture_data(params);
				//PA_RunInMainProcess((PA_RunInMainProcessProcPtr)ocr_picture_data, params);
				break;

			case 2:
				ocr_get_info(params);
				//PA_RunInMainProcess((PA_RunInMainProcessProcPtr)ocr_get_info, params);
				break;
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

/*
this is a async (coroutine) version
not used because sync is easier in 4D
(we have our native async framework if need be)
*/

#if VERSIONWIN

static task<void> task_ocr_picture_data(std::vector<byte>& buf, std::wstring& result) {

	IBuffer buffer = CryptographicBuffer::CreateFromByteArray(buf);
	InMemoryRandomAccessStream randomAccessStream;
	co_await randomAccessStream.WriteAsync(buffer);
	BitmapDecoder decoder = co_await BitmapDecoder::CreateAsync(randomAccessStream);
	SoftwareBitmap bitmap = co_await decoder.GetSoftwareBitmapAsync(BitmapPixelFormat::Bgra8, BitmapAlphaMode::Premultiplied);
	
	auto engine = OcrEngine::TryCreateFromUserProfileLanguages();

	OcrResult ocrResult = co_await engine.RecognizeAsync(bitmap);
	result = ocrResult.Text().c_str();
}

#endif

static void collection_push(PA_CollectionRef c, PA_ObjectRef value) {

	if (value) {
		PA_Variable v = PA_CreateVariable(eVK_Object);
		PA_SetObjectVariable(&v, value);
		PA_SetCollectionElement(c, PA_GetCollectionLength(c), v);
		PA_ClearVariable(&v);
	}
}

static void collection_push_c(PA_CollectionRef c, PA_CollectionRef value) {

	if (value) {
		PA_Variable v = PA_CreateVariable(eVK_Collection);
		PA_SetCollectionVariable(&v, value);
		PA_SetCollectionElement(c, PA_GetCollectionLength(c), v);
		PA_ClearVariable(&v);
	}
}

static void get_info(PA_ObjectRef returnValue){

	PA_CollectionRef c = PA_CreateCollection();

#if VERSIONWIN

    auto languages = OcrEngine::AvailableRecognizerLanguages();
    
	for (auto const& language : languages)
	{
		PA_ObjectRef o = PA_CreateObject();
		ob_set_a(o, L"nativeName", (const wchar_t *)language.NativeName().c_str());
		ob_set_a(o, L"displayName", (const wchar_t *)language.DisplayName().c_str());
		ob_set_a(o, L"languageTag", (const wchar_t *)language.LanguageTag().c_str());
		ob_set_a(o, L"script", (const wchar_t *)language.Script().c_str());
		collection_push(c, o);
	}
    
#endif
    
	ob_set_c(returnValue, L"languages", c);
}

#if VERSIONWIN

static task<ocr_result> ocr_get_string(std::vector<byte>& buf, std::wstring& lang)
{
	ocr_result result;

	auto b = std::make_shared< std::vector<byte> >(buf);
	auto l = std::make_shared< std::wstring >(lang);
	auto r = std::make_shared< ocr_result >(result);

	return create_task([b, l, r]
	{
		IBuffer buffer = CryptographicBuffer::CreateFromByteArray(*b);

		InMemoryRandomAccessStream randomAccessStream;
		randomAccessStream.WriteAsync(buffer).get();
		BitmapDecoder decoder = BitmapDecoder::CreateAsync(randomAccessStream).get();
		SoftwareBitmap bitmap = decoder.GetSoftwareBitmapAsync(BitmapPixelFormat::Bgra8, BitmapAlphaMode::Premultiplied).get();

		Windows::Globalization::Language language(*l);

		auto engine = OcrEngine::IsLanguageSupported(language) ? OcrEngine::TryCreateFromLanguage(language) : OcrEngine::TryCreateFromUserProfileLanguages();

		ocr_lines www;

		OcrResult ocrResult = engine.RecognizeAsync(bitmap).get();

		for (auto const& line : ocrResult.Lines())
		{
			ocr_words ww;
			for (auto const& word : line.Words())
			{
				ocr_word w(word.Text(), word.BoundingRect());
				ww.push_back(w);
			}
			www.push_back(ww);

		}
		*r = ocr_result(ocrResult.Text(), www);
	}).then([r]
	{
		return *r;
	});
}

#endif

void ocr_get_info(PA_PluginParameters params) {

	PA_ObjectRef returnValue = PA_CreateObject();
	get_info(returnValue);
	PA_ReturnObject(params, returnValue);
}

void ocr_picture_data(PA_PluginParameters params) {

	PA_ObjectRef returnValue = PA_CreateObject();

#if VERSIONWIN
    
	PA_long32 len = PA_GetBlobParameter(params, 1, NULL);

	if (len)
	{
		std::vector<byte>buf(len);
		PA_GetBlobParameter(params, 1, &buf[0]);

		PA_Unistring *ustr = PA_GetStringParameter(params, 2);
		std::wstring lang;
		if ((ustr) && (ustr->fLength)){
			lang = std::wstring((const wchar_t*)ustr->fString, ustr->fLength);
		}

		/*
		call a task from a task, because the get() method will throw a debug error
		!is_sta() when a blocking call is made from the main thread
		*/

		auto t = ocr_get_string(buf, lang);

		ocr_result ocr = t.get();

		std::wstring text = ocr.first.c_str();

		ob_set_a(returnValue, L"fullText", (const wchar_t *)text.c_str());

		auto lines = ocr.second;

		PA_CollectionRef l = PA_CreateCollection();
		for (auto const& words : lines)
		{
			PA_CollectionRef w = PA_CreateCollection();
			for (auto const& word : words)
			{
				PA_ObjectRef o = PA_CreateObject();
				ob_set_a(o, L"word", (const wchar_t *)word.first.c_str());
				Rect rect = word.second;
				ob_set_n(o, L"x", rect.X);
				ob_set_n(o, L"y", rect.Y);
				ob_set_n(o, L"height", rect.Height);
				ob_set_n(o, L"width", rect.Width);
				collection_push(w, o);
			}
			collection_push_c(l, w);
		}
		ob_set_c(returnValue, L"lines", l);
	}	

#endif
    
	PA_ReturnObject(params, returnValue);
}

